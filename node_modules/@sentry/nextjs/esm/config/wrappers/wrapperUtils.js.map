{"version":3,"file":"wrapperUtils.js","sources":["../../../../src/config/wrappers/wrapperUtils.ts"],"sourcesContent":["import { captureException } from '@sentry/core';\nimport { getActiveTransaction } from '@sentry/tracing';\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\nexport async function callDataFetcherTraced<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArgs: Parameters<F>,\n  options: {\n    parameterizedRoute: string;\n    dataFetchingMethodName: string;\n  },\n): Promise<ReturnType<F>> {\n  const { parameterizedRoute, dataFetchingMethodName } = options;\n\n  const transaction = getActiveTransaction();\n\n  if (!transaction) {\n    return origFunction(...origFunctionArgs);\n  }\n\n  // TODO: Make sure that the given route matches the name of the active transaction (to prevent background data\n  // fetching from switching the name to a completely other route) -- We'll probably switch to creating a transaction\n  // right here so making that check will probabably not even be necessary.\n  // Logic will be: If there is no active transaction, start one with correct name and source. If there is an active\n  // transaction, create a child span with correct name and source.\n  transaction.name = parameterizedRoute;\n  transaction.metadata.source = 'route';\n\n  // Capture the route, since pre-loading, revalidation, etc might mean that this span may happen during another\n  // route's transaction\n  const span = transaction.startChild({\n    op: 'nextjs.data',\n    description: `${dataFetchingMethodName} (${parameterizedRoute})`,\n  });\n\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (err) {\n    if (span) {\n      span.finish();\n    }\n\n    // TODO Copy more robust error handling over from `withSentry`\n    captureException(err);\n    throw err;\n  }\n}\n"],"names":[],"mappings":";;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}